<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>admin documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">admin documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  tagStyle</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/views/outfits/foto-outfit/foto-outfit.page.ts</code>
        </p>






            <section data-compodoc="block-indexables">
    <h3 id="inputs">Indexable</h3>
        <table class="table table-sm table-bordered">
            <tbody>
                <tr>
                    <td class="col-md-4">
                        <code>[key: string]:    <code>literal type</code>
</code>
                    </td>
                </tr>
                        <tr>
                            <td class="col-md-4">
                                <div class="io-line">Defined in <a href="" data-line="10" class="link-to-prism">src/app/views/outfits/foto-outfit/foto-outfit.page.ts:10</a></div>
                            </td>
                        </tr>
            </tbody>
        </table>
</section>

    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, ElementRef, EventEmitter, inject, Input, OnInit, Output, signal, ViewChild, WritableSignal } from &#x27;@angular/core&#x27;;
import { alert, confirm } from &#x27;../../../widgets/ui-dialogs&#x27;;
import { DomSanitizer } from &#x27;@angular/platform-browser&#x27;;
import { PopUpService } from &#x27;../../../services/popup.service&#x27;;
import { CommonModule } from &#x27;@angular/common&#x27;;
import { Tag } from &#x27;../../../services/outfit.service&#x27;;
import { FormsModule } from &#x27;@angular/forms&#x27;;


interface tagStyle {
  [key: string]: {
    left: string;
    top: string;
  }

}
@Component({
  selector: &#x27;app-foto-outfit&#x27;,
  templateUrl: &#x27;./foto-outfit.page.html&#x27;,
  styleUrls: [&#x27;./foto-outfit.page.scss&#x27;],
  standalone: true,
  imports: [CommonModule, FormsModule]

})

export class FotoOutfitPage implements OnInit {
  // ... rest of the class code



  @ViewChild(&#x27;imageElement&#x27;, { static: false }) imageElement: ElementRef | undefined;
  @ViewChild(&#x27;fileInput&#x27;) fileInput!: ElementRef;

  @Input() image &#x3D; signal&lt;string&gt;(&#x27;&#x27;);
  @Input() showTag &#x3D; signal&lt;boolean&gt;(false);
  @Input() tags &#x3D; signal&lt;Tag[]&gt;([]);
  @Input() enableSetTagsImage: boolean &#x3D; true


  @Input() enableNewImagecaptured &#x3D; signal&lt;boolean&gt;(true);

  @Output() eventFotoCaptured: EventEmitter&lt;any&gt; &#x3D; new EventEmitter&lt;any&gt;(); //Emit all&#x27;esterno;
  @Output() eventImageTags: EventEmitter&lt;any&gt; &#x3D; new EventEmitter&lt;any&gt;(); //Emit all&#x27;esterno;
  @Output() eventBeforeFotoCaptured: EventEmitter&lt;any&gt; &#x3D; new EventEmitter&lt;any&gt;(); //Emit all&#x27;esterno;
  @Output() eventImageShowFull: EventEmitter&lt;any&gt; &#x3D; new EventEmitter&lt;any&gt;(); //Emit all&#x27;esterno;





  tagStyle: any &#x3D; {}
  imageLoading &#x3D; signal(true)
  tagToggleButton: any &#x3D; {};
  blobImg: any;
  fileName: any;
  format: string &#x3D; &#x27;&#x27;;
  openFullScreen: boolean &#x3D; false;
  propertiesModal &#x3D; inject(PopUpService);





  ngOnInit(): void {

  }

  ngAfterViewInit(): void {

    if (this.imageElement) {

      this.imageElement.nativeElement.onload &#x3D; (event: Event) &#x3D;&gt; {

        this.imageLoading.set(true)
        this.onImageLoad(event);

      };

      // Nel caso in cui si verifichi un errore nel caricamento dell&#x27;immagine
      this.imageElement.nativeElement.onerror &#x3D; () &#x3D;&gt; {
        this.imageLoading.set(false);  // Nascondi il loader anche in caso di errore
      };

    }

    //Nascondi loader se sto in inserimento
    if (this.enableNewImagecaptured()) {
      this.imageLoading.set(false);
    }


  }

  onImageLoad(event: Event): void {
    if (this.tags().length &gt; 0) {
      const image &#x3D; this.imageElement?.nativeElement as HTMLElement;
      const rect &#x3D; image.getBoundingClientRect();
      this.setDisplayTag(rect)
    }

    this.imageLoading.set(false);  // Nasconde il loader
  }

  chooseFile(): void {
    this.fileInput.nativeElement.click();

  }

  async captureImage(event: Event) {
    if (this.tags.length &gt; 0 &amp;&amp; typeof this.image !&#x3D;&#x3D; &#x27;undefined&#x27;) {
      let respo &#x3D; await this.confirmChangeFoto();
      if (!respo) {
        return;
      }
    }

    const input &#x3D; event.target as HTMLInputElement;
    if (input.files &amp;&amp; input.files[0]) {
      const file &#x3D; input.files[0];

      if (this.validateFile(file)) {
        const reader &#x3D; new FileReader();
        this.imageLoading.set(true)
        reader.onload &#x3D; async (e: ProgressEvent&lt;FileReader&gt;) &#x3D;&gt; {
          const dataUrl &#x3D; e.target?.result as string;

          // Ridimensiona l&#x27;immagine prima di emetterla
          try {
            const maxWidth &#x3D; 600;
            const type &#x3D; file.type.replace(&#x27;image/&#x27;, &#x27;&#x27;)
            const resizedImage &#x3D; await this.resizeImage(dataUrl, maxWidth, 600); // Puoi cambiare &#x27;jpeg&#x27; con il formato desiderato e 800 con la larghezza massima desiderata

            // Assegna il valore ridimensionato
            this.image.set(resizedImage.dataUrl);
            this.imageLoading.set(false);

          } catch (error) {
            console.error(&#x27;Errore durante il ridimensionamento dell\&#x27;immagine:&#x27;, error);
            this.imageLoading.set(false);
          }
        };

        // Legge il file come data URL
        reader.readAsDataURL(file);
      } else {
        alert(&#x27;File non valido. Seleziona un file immagine di dimensioni inferiori a 2MB.&#x27;, &#x27;Attenzione!&#x27;);
      }


      /* let eventToEmit &#x3D; {
        img: this.dataURLtoBlob(this.image),
        imgName: this.fileName,
        contentType: contentType,
      };
      this.eventFotoCaptured.emit(eventToEmit); */
    }
  }

  validateFile(file: File): boolean {
    const maxSize &#x3D; 5 * 1024 * 1024 // 2MB
    const allowedTypes &#x3D; [&#x27;image/jpeg&#x27;, &#x27;image/png&#x27;, &#x27;image/gif&#x27;];
    return file.size &lt;&#x3D; maxSize &amp;&amp; allowedTypes.includes(file.type);
  }


  resizeImage(dataUrl: string, maxWidth: number, maxHeight: number): Promise&lt;{ dataUrl: string; format: string }&gt; {
    return new Promise((resolve, reject) &#x3D;&gt; {
      const img &#x3D; new Image();
      img.src &#x3D; dataUrl;

      img.onload &#x3D; () &#x3D;&gt; {
        let canvas &#x3D; document.createElement(&#x27;canvas&#x27;);
        const ctx &#x3D; canvas.getContext(&#x27;2d&#x27;);

        let width &#x3D; img.width;
        let height &#x3D; img.height;

        // Calcolo del ridimensionamento mantenendo il rapporto d&#x27;aspetto
        if (width &gt; maxWidth || height &gt; maxHeight) {
          const widthRatio &#x3D; maxWidth / width;
          const heightRatio &#x3D; maxHeight / height;
          const bestRatio &#x3D; Math.min(widthRatio, heightRatio);

          width *&#x3D; bestRatio;
          height *&#x3D; bestRatio;
        }

        canvas.width &#x3D; width;
        canvas.height &#x3D; height;

        ctx!.drawImage(img, 0, 0, width, height);

        const resizedDataUrl &#x3D; canvas.toDataURL();
        resolve({ dataUrl: resizedDataUrl, format: resizedDataUrl.split(&quot;;&quot;)[0].split(&quot;/&quot;)[1] });
      };

      img.onerror &#x3D; (err) &#x3D;&gt; {
        reject(err);
      };
    });
  }


  async confirmChangeFoto(): Promise&lt;boolean&gt; {
    return new Promise(async () &#x3D;&gt; {
      return confirm(&quot;Procedendo perderai anche tutti i tag associati e la priorità acquisita nell&#x27;elenco&quot;, &quot;Attenzione!&quot;, (resp &#x3D;&gt; {
        if (resp) {

          this.tags &#x3D; signal([]);
          this.image &#x3D; signal(&#x27;&#x27;);

          let eventtoEmit &#x3D; {
            tags: this.tags
          }
          this.eventImageTags.emit(eventtoEmit);
        }
      }))



    });
  }

  async editTag(tag: Tag) {
    const modalResponse &#x3D; await this.openModal(tag)
    if (Object.keys(modalResponse).length &gt; 0) {


      const tags &#x3D; this.tags()
      let indexTag &#x3D; tags.findIndex(r &#x3D;&gt; r.id &#x3D;&#x3D; tag.id)
      let link &#x3D; !modalResponse.link ? &#x27;#&#x27; : modalResponse.link
      let images &#x3D; !modalResponse.Images ? &#x27;&#x27; : modalResponse.Images
      images &#x3D; modalResponse.images ? modalResponse.images : images
      images &#x3D; modalResponse.imageUrl ? modalResponse.imageUrl : images
      tags[indexTag] &#x3D;
      {
        id: tag.id,
        name: modalResponse.name,
        x: tag.x,
        y: tag.y,
        link: link,
        color: modalResponse.color,
        brend: modalResponse.brend,
        images: images,
        prezzo: modalResponse.prezzo,
        outfitCategory: modalResponse.outfitCategory,
        outfitSubCategory: modalResponse.outfitSubCategory

      }

      this.tags.set(tags);


      let eventtoEmit &#x3D; {
        tags: this.tags()
      }
      this.eventImageTags.emit(eventtoEmit)
    }

  }

  async addTag(event: any) {

    if (!this.enableSetTagsImage) {

      this.eventImageShowFull.emit()
      return
    }

    let name &#x3D; &#x27;&#x27;
    let link &#x3D; &#x27;&#x27;

    let result: any &#x3D; await this.openModal();
    if (Object.keys(result).length &gt; 0) {
      const image &#x3D; this.imageElement?.nativeElement as HTMLElement;
      const rect &#x3D; image.getBoundingClientRect();
      const x &#x3D; (event.clientX - rect.left) / rect.width;
      const y &#x3D; (event.clientY - rect.top) / rect.height;
      let link &#x3D; !result.link ? &#x27;#&#x27; : result.link
      let brend &#x3D; !result.brend ? null : result.brend
      let prezzo &#x3D; !result.prezzo ? null : result.prezzo
      let id &#x3D; !result.id ? result.name.replace(&#x27; &#x27;, &#x27;_&#x27;) : result.id;
      let images &#x3D; !result.Images ? &#x27;&#x27; : result.Images
      images &#x3D; result.imageUrl ? result.imageUrl : images
      let tags &#x3D; []
      tags.push(
        {
          id: id,
          name: result.name,
          x: x,
          y: y,
          link: link,
          color: result.color,
          brend: brend,
          prezzo: prezzo,
          price: prezzo,
          images: images,
          outfitCategory: result.outfitCategory,
          outfitSubCategory: result.outfitSubCategory

        }

      );

      this.tags.set(tags);
      this.setDisplayTag(rect)
      this.setDisplayButtonTag(rect);

      let eventtoEmit &#x3D; {
        tags: this.tags()
      }
      this.eventImageTags.emit(eventtoEmit)
    }
    return

  }

  setDisplayTag(rect: DOMRect) {

    this.tags().forEach(tag &#x3D;&gt; {
      this.tagStyle[tag.id] &#x3D; {
        left: &#x60;${tag.x * rect.width}px&#x60;,
        top: &#x60;${tag.y * rect.height}px&#x60;
      };
    });


  }

  toggleTags() {
    this.showTag.update(prev &#x3D;&gt; !prev);
  }

  setDisplayButtonTag(rect: DOMRect) {

    const bottomOffset &#x3D; 0.1 * rect.height;  // Offset dal fondo (10% dell&#x27;altezza dell&#x27;immagine)
    const rightOffset &#x3D; 0.05 * rect.width;    // Offset da destra (5% della larghezza dell&#x27;immagine)

    this.tagToggleButton &#x3D; {
      bottom: &#x60;${bottomOffset}px&#x60;,
      right: &#x60;${rightOffset}px&#x60;,
      position: &#x27;absolute&#x27;,
      zIndex: 10
    };
  }

  async openModal(tagData?: Tag): Promise&lt;any&gt; {
    console.log(&#x27;openModal&#x27;, tagData);
    /*  
     let images &#x3D; !tagData.Images ? &#x27;&#x27; : tagData.Images
      images &#x3D; tagData.imageUrl ? tagData.imageUrl : images */

    let guid &#x3D; Math.random().toString().replace(&quot;0.&quot;, &quot;&quot;);
    let InstanceData &#x3D; {
      service: &#x27;tagForm&#x27;,
      editData: tagData
    }
    let data &#x3D; {}

    this.propertiesModal.setNewPopUp(guid, &#x27;DynamicFormComponent&#x27;, null, 800, null, InstanceData, false, true, &quot;Modifica Tag&quot;, &#x27;&#x27;, false)


    return new Promise((resolve, reject) &#x3D;&gt; {
      this.propertiesModal.outputComponent.subscribe(async respo &#x3D;&gt; {
        if (respo.guid &#x3D;&#x3D;&#x3D; guid) {

          if (respo.name &#x3D;&#x3D;&#x3D; &#x27;functionalInputClick&#x27;) {
            this.openOutfitProducts()
            console.log(&#x27;functionalInputClick--&gt;&#x27;, respo);
          }


          if (respo.name &#x3D;&#x3D;&#x3D; &#x27;submitForm&#x27;) {
            const resolveC &#x3D; respo.formData;
            this.propertiesModal.destroyCurrentOpenPopUpByGuid(guid);
            //this.propertiesModal.onSubScribe();
            resolve(resolveC); // Risolvi la Promise con i dati del form
          }

          if (respo.name &#x3D;&#x3D;&#x3D; &#x27;cancelForm&#x27;) {
            this.propertiesModal.destroyCurrentOpenPopUpByGuid(guid);
            resolve(false); // Risolvi la Promise
          }
        }

      });
    });

    return this.propertiesModal.getOutputComponent(guid)


  }

  removeTag(tagId: any) {
    const newTags &#x3D; this.tags().filter(tag &#x3D;&gt; tag.id !&#x3D;&#x3D; tagId);
    this.tags.set(newTags);
  }

  async openOutfitProducts() {

    let guid &#x3D; Math.random().toString().replace(&quot;0.&quot;, &quot;&quot;);
    this.propertiesModal.setNewPopUp(guid, &#x27;OutfitProductsComponent&#x27;, null, 1000, null, {}, true, true, &quot;Prodotti Outfit&quot;, &#x27;&#x27;, true)
    ///let respo &#x3D; await this.propertiesModal.getOutputComponent(guid)



    this.propertiesModal.outputComponent.subscribe(async resulOutputComponent &#x3D;&gt; {
      if (resulOutputComponent.guid &#x3D;&#x3D;&#x3D; guid) {


        console.log(resulOutputComponent)

      }
    });
  }

  /**utility**/

  // Funzione per convertire dataURL (BASE64) in Blob
  private dataURLtoBlob(dataUrl: string): Blob {
    const arr &#x3D; dataUrl.split(&#x27;,&#x27;), mime &#x3D; arr[0].match(/:(.*?);/)![1];
    const bstr &#x3D; atob(arr[1]);
    let n &#x3D; bstr.length;
    const u8arr &#x3D; new Uint8Array(n);

    while (n--) {
      u8arr[n] &#x3D; bstr.charCodeAt(n);
    }

    return new Blob([u8arr], { type: mime });
  }

  onImageError(event: any) {

    event.target.src &#x3D; &#x27;assets/images/fallback-image.jpg&#x27;;

  }

  closeModalFullScreen() {
    this.openFullScreen &#x3D; false;
  }


}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'tagStyle.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
